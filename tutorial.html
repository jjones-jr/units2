<h1 id="getting-started">Getting Started</h1>
<h2 id="overview">Overview</h2>
<p>There are two protocols: units should be <code>Unitlike</code> and amounts that have units should be <code>Dimensionful</code>.</p>
<p>The reference implementation of <code>Dimensionful</code> is the <code>amount</code> type. The reference implementation of <code>Unitlike</code> is the <code>IFnUnit</code> type (which, as its name suggests, also implements <code>clojure.lang.IFn</code>).</p>
<h2 id="getting-started-at-the-repl">Getting Started (at the REPL)</h2>
<p>Start by loading a library of units and some standard operations defined over amounts.</p>
<pre><code>(require &#39;[units2.astro :refer :all])
(require &#39;[units2.ops :as op])</code></pre>
<h1 id="working-with-ifnunits">Working with IFnUnits</h1>
<p>The unit for meters in the astro library is <code>m</code>, and an amount representing 7 meters is created by</p>
<pre><code>(m 7)</code></pre>
<p>To convert an amount to another unit, just act with that unit on the given amount:</p>
<pre><code>(let [a (m 6)]
  [(km a) (m (km 0.5))]
) ; --&gt; amounts of 0.006 km and 500 meters</code></pre>
<p>Sometimes you may want to extract the value of an amount as a regular clojure number. In that case you'll have to fall back on the <code>Dimensionful</code> protocol and write</p>
<pre><code>(getValue amount unit)</code></pre>
<p>That said, the only reason to extract a value from an amount is to interact with pre-existing clojure functions. To promote functional code, unit wrap/unwrap methods over 1-to-1 functions are part of the reference implementation:</p>
<pre><code>(let [sin (unwrap-in rad #(Math/sin %))
      atan (warp-out rad #(Math/atan %))
      angle (deg 90)]
  (atan (sin angle)))</code></pre>
<h1 id="mathematics-with-units----the-ops-library">Mathematics with units -- the <code>ops</code> library</h1>
<p>The usual operations (<code>+</code>,<code>-</code>,<code>*</code>,<code>/</code>,<code>&lt;</code>,<code>&gt;</code>,<code>==</code>,<code>exp</code>,<code>log</code>, etc.) are defined over usual numbers. The <code>units2.ops</code> namespace redefines these operations in a way that behaves correctly with units.</p>
<pre><code>(let [x (m 10)
      y (km 0.1)]
  (op/+ x y))

(op/== (kg 1) (g 1000)) ; true</code></pre>
<h2 id="macros">Macros</h2>
<p>Constantly working out of the <code>ops</code> namespace can be a bit tedious, especially for very mathy code, so there's a couple of macros that locally define +,-,*, etc to be the units2.ops/... versions to make writing math easier:</p>
<pre><code>(op/with-unit-arithmetic
  (+ (m 7) (* (m 8) 4))
)

(op/with-unit-comparisons
  (&lt; (m 2) (min (cm 180) (m 0.18)))
)</code></pre>
<p>These are joined together into the super-macro <code>(with-unit- [keywords] body)</code>, which expands into (possibly nested) calls to these other macros based on the keywords.</p>
<h2 id="exponentiation">Exponentiation</h2>
<p>Exponentials and logarithms can be a bit subtle, but given how often they occur in application using them should not be difficult.</p>
<p>Besides <code>expt</code> (a new function we'll discuss later), the usual <code>java.lang.math</code> functions are redefined over dimensionless ratios of amounts using the ages-old &quot;<code>atan2</code>&quot; convention <code>atan2(a,b) == atan(a/b)</code>.</p>
<pre><code>(== 3.0 (op/log10 (km 1) (m 1))) ; true</code></pre>
<p>They still accept arity-one definitions over regular numbers to behave nicely in <code>with-unit-expts</code>; and intrepid users can read the source to learn about <code>*unit-warnings-are-errors*</code> and arity-one exponentitation with units.</p>
<p>The <code>expt</code> function (following the name of <code>pow</code> in Scheme) is a <code>pow</code> for amounts with units.</p>
<pre><code>(expt (m 1) 3) ; --&gt; volume</code></pre>
<h2 id="pitfalls">Pitfalls</h2>
<p>Some standard operations (like <code>pos?</code>) become less meaningful. TODO: discuss this further.</p>
<h1 id="advanced-features">Advanced Features</h1>
<p>Now that we've seen how to work within the reference library, let's focus on how to extend it.</p>
<h2 id="calculus">Calculus</h2>
<p>We can do calculus with amounts by leveraging existing implementations of derivatives and integrals of functions (such as Incanter or Apache Commons). The functions in <code>units2.calc</code> handle univariate calculus for any combination of regular/dimensionful quantities in the domain/range of the function.</p>
<h2 id="defining-custom-units">Defining Custom Units</h2>
<p>It's easy to create your own IFnUnits: they can be created with <code>AsUnit</code> or with <code>-&gt;IFnUnit</code>; they can also be bound to symbols with the <code>defunit</code> macro. TODO: expand on this.</p>
<h2 id="extending-the-protocols">Extending the protocols</h2>
<p>TODO: Say something about this.</p>
<h1 id="closing-thoughts-roadmap">Closing Thoughts / Roadmap</h1>
<p>bla bla bla</p>
